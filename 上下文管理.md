# 上下文管理

- 索引小（0、1、2…）：更早/更旧的消息
- 索引大（…n-2、n-1）：更晚/更新的消息（越接近当前时刻）

### 1、压缩工具消息

从旧->新遍历消息，找到最老的连续的工具回复，然后压缩。

### 2、卸载超大消息（最新消息保护）

默认保护最近50条消息不受卸载。

- 阈值：5K
- lastkeep：50
- 逻辑：比如有200条消息，现在需要卸载超大消息体，那么就从索引0开始，到150遍历，找到所有大于5k的消息，然后卸载它们。

### 3、卸载超大消息

还是200条消息，然后找到最新的消息索引，比如其索引是198。那么遍历0-197条消息，找到所有大于5k的消息，然后卸载它们。

> 卸载：offload(uuid, offloadMsg)
>
> 被替换的文本里会有这样的提示：<!-- CONTEXT_OFFLOAD uuid=... -->
>
> 后续通过uuid进行回放消息：reload(uuid)

### 4、摘要历史对话消息

- 以最新一条回复为边界，判断是否为最后一条消息的逻辑是：从新->旧遍历所有消息，找到是ASSISTANT且不包含ToolUseBlock/ToolResultBlock的消息。
- 在边界之前，收集所有“user→assistant”轮次对（userAssistantPairs）。也是遍历所有消息，如果类型是USER，就记录其索引i，从i往后遍历，知道找到不是Assistant的消息，记录其索引j，那么i就是USER，i到j之间的就是assistant，这就算做一轮对话了。这一步会收集到多轮对话。
- 对于每一轮对话，startIndex = userIndex + 1，endIndex = assistantIndex，将这个范围的原始消息卸载到外部存储，然后用模型生成摘要。
- 最终该轮从user, (tool.../assistant...)变成了user, summaryMsg。
- 逻辑是：比如有200条消息，找到最新的assistantIndex=198，然后遍历0-197条消息，找到所有user-assistants消息对，将assistants进行摘要处理（发给LLM处理），然后将摘要后的assistants替换原始消息，原始消息卸载到外部存储。

### 5、摘要当前轮对话的超大消息

和策略4有所不同的是，比如一共200条消息，找到最新的user消息，比如索引是198，那么从199-200遍历，找到所有大于5K的消息进行摘要并压缩。

### 6、摘要当前轮对话所有消息

举例子，比如一共200条消息，找到最新的user消息，比如索引是198，那么startIndex=199，endIndex=200。

> 这里有一个边界，我们知道tool调用是成对的：ToolUse和ToolResult。因此需要检查第200条消息是否是ToolUse，如果是，说明ToolResult还没有回来，需要将endIndex--，变成199。

最终，startIndex=199，endIndex=199。摘要这之间的所有消息，并卸载原消息。