# codex-cli的工具调用和沙箱环境

工具执行的地方是：codex-rs/core/src/tools/registry.rs

![image-20260131172430059](C:\Users\geniu\AppData\Roaming\Typora\typora-user-images\image-20260131172430059.png)

## 数据结构

- codex-rs/core/src/config/mod.rs：解析~/.codex/config.toml配置项的地方，它是基础配置，
- session_configuration
- turn：一次完整的用户问答交互」，也就是「用户发起一次查询 → CLI 返回对应结果」的单次循环。
- approval_policy：config.toml配置项，值是"on-request" 或 "never" / "on-failure" / "untrusted"。优先级是：
- sandbox_mode：config.toml配置项，值是"read-only" 或 "workspace-write" 或 "danger-full-access"。优先级是：CLI override sandbox_mode_override->profile 的 profile_sandbox_mode->config.toml 的 self.sandbox_mode，如果都没有，默认是WorkspaceWrite。
- profile：config.toml 里 profiles 这个 map 里的一个命名条目，参与最终配置合并时，优先级在：CLI override 之下、全局 config.toml之上。
- codex-linux-sandbox：它是 Linux 沙箱 helper，当spawn_child_async时，执行的命令的arg0是codex-linux-sandbox的时候（例如ExecEnv），就会安装 landlock/seccomp 在 exec 前对当前线程安装内核限制，然后执行ExecEnv当中的目标命令。主要逻辑在 linux_run_main.rs 中。

------

## 0、审批策略和沙箱策略

approval_policy和sandbox_policy都是在TurnContext内，同一个turn内，所有工具可以看到同一份策略。

审批配置推导：CLI override -> profile -> config.toml

审批配置：on-request 、 never  \ on-failure 、 untrusted

> never  \ on-failure ：不需要审批，Skip
>
> untrusted：需要审批，NeedsApproval
>
> on-request：如果沙箱策略是 danger-full-access 或者 external-sandbox 就不需要审批，否则需要审批。

审批策略：有三种，Skip、NeedsApproval、Forbidden（工具自定义的策略）

------

## 1、ToolOrchestrator编排器

```
ToolOrchestrator#run()方法
/**
这个方法是整个工具执行链路的“总编排器”，把审批（approval）、选择沙箱（sandbox selection）、执行（attempt）、以及**沙箱拒绝后的升级重试（retry without sandbox）**统一串起来。它本身不直接执行命令，而是驱动具体 tool runtime 去跑。
*/
```

主体逻辑分两个部分：先审批，再选择沙箱执行

#### 阶段 A：审批（Approval）

计算本次调用的审批要求 ExecApprovalRequirement，有三种结果：Skip（不需要审批）、NeedsApproval（需要审批）、Forbidden（拒绝执行）

1、优先使用tool自己提供的审批要求

2、否则走默认审批策略：

- Never/OnFailure：默认不弹审批
- OnRequest：在受限沙箱（非 DangerFullAccess/ExternalSandbox）下需要
- UnlessTrusted：总是审批

#### 阶段 B：第一次执行（First Attempt in Sandbox）

- 沙箱：所谓的沙箱不是一个容器或者什么系统，实际上它是一条特殊的命令，叫做codex-linux-sandbox helper，执行该helper时主进程会fork出来一个子进程来执行真正的目标命令，但是在执行目标命令前，helper对子进程会安装沙箱策略，也就是Landlock、seccomp。

- Landlock：对文件系统做限制，尤其是写

- seccomp：secure computing mode缩写，安全模式，对系统调用做了限制，尤其是网络

- 安装沙箱策略：根据 sandbox_policy 对子进程做Landlock和seccomp限制。

- CommandSpec：命令描述，它包含了目标命令、根路径、沙箱限制等。

- ExecEnv：就是上面说的helper，它是一个命令，带有cwd、sandbox_policy、command

- transform：将commandSpec转换成可执行环境ExecEnv。

  > 举例子：
  >
  > 原始命令是 ls -a，那么经过transform后，ExecEnv =["/path/to/codex-linux-sandbox", "--sandbox-policy-cwd", "...", "--sandbox-policy", "{...json...}", "--", "ls", "-a"]

------

## 2、ShellHandler

run_exec_like 方法负责把“模型的 tool call”翻译成一次可执行请求，并把控制权交给 orchestrator；真正的审批/沙箱/执行策略都在orchestrator/runtime 里完成。

`codex-rs/core/src/tools/handlers/shell.rs`

![image-20260131174936918](C:\Users\geniu\AppData\Roaming\Typora\typora-user-images\image-20260131174936918.png)

编排器会计算审批策略、初始化沙箱策略，然后交给统一执行的方法run(……)。

这是一个抽象方法，有3个实现。

![image-20260201223248339](C:\Users\geniu\AppData\Roaming\Typora\typora-user-images\image-20260201223248339.png)

在shellHandler里看ShellRuntime实现。

在这个实现里，它会构造CommandSpec描述，并通过spec描述将commandSpec转换成可执行环境ExecEnv。

> ExecEnv类似于：
>
> ```shell
> ExecEnv =["codex-linux-sandbox", "--sandbox-policy-cwd", "...", "--sandbox-policy", "{...json...}", "--", "ls", "-a"]
> ```

### 安装沙箱

编排层只选择沙箱策略，不安装沙箱。对于ShellHandler类型命令：

ShellHandler → ToolOrchestrator（选沙箱） → ShellRuntime::run → attempt.env_for → SandboxManager::transform（把命令包成 codex-linux-sandbox ... -- <cmd>） → exec/spawn_child_async 启动 helper → helper 安装 landlock/seccomp → helper exec 目标命令。

> Linux 下“启动 helper + 安装 landlock/seccomp”的链路是：
>   1. ShellRuntime::run 构造 CommandSpec
>   2. SandboxAttempt.env_for → SandboxManager::transform 把命令包装成codex-linux-sandbox --sandbox-policy ... -- <cmd>（生成 ExecEnv）
>   3. execute_exec_env → exec → spawn_child_async 启动的 program 就是codex-linux-sandbox
>   4. codex-linux-sandbox 进程内部：解析 --sandbox-policy → 安装seccomp/landlock → execvp 目标命令